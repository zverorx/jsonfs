# Руководство пользователя

## Содержание

* [Введение](#введение)
* [Предусловия](#предусловия)
* [Получение проекта](#получение-проекта)
	* [Скачать архив](#скачать-архив)
	* [Клонировать репозиторий](#клонировать-репозиторий)
* [Сборка](#сборка)
	* [Компиляция и установка](#компиляция-и-установка)
	* [Удаление](#удаление)
	* [Очистка](#очистка)
	* [Подсказки](#подсказки)
* [Организация файловой системы](#организация-файловой-системы)
	* [Общие принципы](#общие-принципы)
	* [Десериализация и сериализация](#десериализация-и-сериализация)
		* [Массивы](#массивы)
		* [Примитив верхнего уровня](#примитив-верхнего-уровня)
		* [Слеш в ключах](#слеш-в-ключах)
		* [Изменение cпециального префикса](#изменение-cпециального-префикса)
	 * [Специальные файлы](#специальные-файлы)
	 * [Атрибуты файлов](#атрибуты-файлов)
* [Использование](#использование)
	* [Монтирование и размонтирование](#монтирование-и-размонтирование)
		* [Монтирование](#монтирование)
		* [Размонтирование](#размонтирование)
	* [Функциональность](#функциональность)
	* [Примечания о чтении и записи](#примечания-о-чтении-и-записи)
	* [Сохранение](#сохранение)
* [Ошибки при использовании](#ошибки-при-использовании)
	* [Ошибки во время сборки](#ошибки-во-время-сборки)
	* [Ошибка во время монтирования](#ошибка-во-время-монтирования)
	* [Ошибки во время записи в файл](#ошибки-во-время-записи-в-файл)
	* [Неправильное сохранение](#неправильное-сохранение)
* [Обратная связь](#обратная-связь)

## Введение

Программа является файловой системой на базе FUSE, которая используется для редактирования файлов формата JSON.

## Предусловия

Проверьте наличие следующих программ:

### Необходимые:

* `gcc`
* `make`
* `libjansson-dev`
* `libfuse3-dev`

>**P.S.** Для установки libfuse3-dev и libjansson-dev используйте ваш пакетный менеджер.

### Опциональные:

* `curl` и `unzip` — если скачиваете архив,
* `git` — если планируете клонировать репозиторий.

## Получение проекта

У вас есть два варианта:

### Скачать архив:

```bash
curl -L -o jsonfs.zip https://github.com/zverorx/jsonfs/archive/refs/tags/latest.zip
```

```bash
unzip jsonfs.zip
```

### Клонировать репозиторий:

```bash
git clone https://github.com/zverorx/jsonfs.git
```

## Сборка

make выполняется исключительно в директории проекта.

### Компиляция и установка

Перейдите в директорию проекта и выполните:

```bash
make && sudo make install
```

Исполняемый файл окажется в директории bin/. В obj/ будут находится файлы промежуточного этапа компиляции (объектные файлы).

Установка подразумевает перемещение bin/jsonfs в /usr/local/bin/. По желанию этот путь можно изменить, переопределив переменную PREFIX.

Например:

```bash
sudo make install PREFIX=mydir
```

Тогда bin/jsonfs будет перемещен в mydir/.

### Удаление

Удаление работает по аналогии с установкой, из директории /usr/local/bin/ будет удален файл jsonfs.

```bash
sudo make uninstall
```

Место, откуда требуется удалить, тоже можно изменить переменной PREFIX:

```bash
sudo make uninstall PREFIX=mydir
```

Тогда jsonfs удалится из mydir/.

### Очистка

Makefile дает возможность удалить файлы, которые являются результатом компиляции.

> Содержимое obj/ и bin/ описано в [Компиляция и установка](#компиляция-и-установка).

Удаление obj/:

```bash
make clean
```

Удаление obj/ и bin/:

```bash
make distclean
```

### Подсказки

Чтобы вспомнить возможности Makefile проекта, необязятельно перечитывать руководство, достаточно воспользоваться:

```bash
make help
```

## Организация файловой системы

### Общие принципы

* Валидный JSON соответствует стандарту RFC 8259, есть поддержка примитива верхнего уровня.
* Ключ - название файла, значение - содержимое файла.
* Сохранение последовательности пар `"ключ": значение` не гарантируется.
* Массивы и объекты становятся каталогами, все остальные типы - файлами.
* Для однозначной идентификации массивов, объектов, примитивов и некоторых символов используется специальный префикс (см. [Десериализация и сериализация](#десериализация-и-сериализация)).
* Файловая система реализует все необходимые функции, привычные в других системах, а так же возможность сохранения после редактирования (см. [Использование](#использование)).
* Значением по умолчанию (например при создании файла) является 0.
* Все файлы виртуальные, то есть не записываются на внешний носитель и хранятся в памяти, контент определяется во время обращения к файлу.
* Файловая система работает исключительно с текстовыми данными, т.е бинарные файлы не поддерживаются.

### Десериализация и сериализация

Десериализация монтируемого файла и сериализация при сохранении, реализуется с помощью библиотеки libjansson, так что если вы сталкнетесь с ограниченями по данным, может быть полезно ознакомится с их документацией по ссылке https://jansson.readthedocs.io/en/latest/index.html.

В качетве примитивных значений доступно: true, false, null, целое число, число с плавающей точкой, "строка".

Некоторые значения не могу быть представлены в рамках любой файловой системы по естественным причинам, так как для индексов массива, примитива верхнего уровня и недопустимых символов есть проблемы в определении названия файла. Для решения этой проблемы используется специальный префикс `@`. Далее рассмотрены случаи его использования.

#### Массивы

При десериализации массив становится объектом, содержащий ключи, начинающиеся со специального префикса. После него идет порядковый номер, начиная с 0.

Например:

```json
{
  "user": "Ivan Petrov", 
  "interests": ["photography", "cooking", "skiing"],
  "phone": null,
  "profile": {
    "city": "Saint Petersburg",
    "street": "Nevsky Prospect",
    "apartment": 45
  }
}
```

Будет представлено в файловой системе как

```
.
├── interests
│   ├── @0 (содержит "photography")
│   ├── @1 (содержит "cooking")
│   └── @2 (содержит "skiing")
├── phone
├── profile
│   ├── apartment
│   ├── city
│   └── street
└── user
```

При сериализации есть важный момент:

> **WARNING**: ЕСЛИ ХОТЯ БЫ ОДИН ФАЙЛ ИЛИ КАТАЛОГ ИМЕЕТ В КАЧЕСТВЕ ПЕРВЫХ СИМВОЛОВ СПЕЦИАЛЬНЫЙ ПРЕФИКС, ТО ЕГО РОДИТЕЛЬ БУДЕТ СЕРИАЛИЗОВАТЬСЯ КАК МАССИВ, В ТОМ ЧИСЛЕ КОРЕНЬ! ИСКЛЮЧЕНИЕ ПРИМИТИВ ВЕРХНЕГО УРОВНЯ И СПЕЦИАЛЬНОЕ ОБОЗНАЧЕНИЕ СЛЕША, ОБА УПОМЯНУТЫ ДАЛЕЕ.

#### Примитив верхнего уровня

При десериализации примитива врехнего уровня, (в рамках jsonfs иногда называется скаляром) он оборачивается в объект, значению выдается ключ `@scalar`.

Например:

```json
123
```

||

\\/

```
.
└── @scalar (содержит 123)
```

Так же работает и в обратную сторону, но

> **WARNING**: ЕСЛИ В КОРНЕ ФАЙЛОВОЙ СИСТЕМЫ ВСТРЕТИТСЯ ФАЙЛ С ИМЕНЕМ `@scalar`, ТО ПРИ СОХРАНЕНИИ В JSON ФАЙЛЕ БУДЕТ ТОЛЬКО ПРИМИТИВ, ВСЕ ОСТАЛЬНЫЕ ФАЙЛЫ БУДУТ ПРОИГНОРИРОВАНЫ. ЕСЛИ `@scalar` БУДЕТ НЕ В КОРНЕ, ОН БУДЕТ ЭЛЕМЕНТОМ МАССИВА.

Например:

```
.
├── file1
├── file2
└── @scalar (содержит 123)
```

||

 \\/

```json
123
```

#### Слеш в ключах

При десериализации, во всех ключах, где есть символ `/` произойдет замена на `@2F`. Во время сериализации аналогично, `@2F` будет заменено на `/`.

> **WARNING**: ЕСЛИ `@2F` БУДУТ ПЕРВЫМИ СИМВОЛАМИ В НАЗВАНИИ, ФАЙЛ НЕ БУДЕТ ВОСПРИНИМАТЬСЯ КАК ЭЛЕМЕНТ МАССИВА.

#### Изменение cпециального префикса

Программа не предоставляет возможности поменять специальный префикс, обозначение скаляра или слеша, но это возможно сделать, путем редактирования исходных текстов. Для этого откройте include/common.h и найдите макросы SPECIAL_PREFIX, SPECIAL_SLASH, SCALAR_NAME, там определены префикс, слеш и скаляр соответственно. Просто запишите туда ту строку, которая вам подходит, на случай если `@` должен восприниматься как обычный символ. После этого [перекомпилируйте проект](#компиляция-и-установка).

### Специальные файлы

Кроме JSON файлов, есть специальные, например привычные `.` и `..`, являющиеся текущим и родительским каталогом соответственно. 

Для управления сериализацией, были введены `.save` и `.status`. При записи в первый из них, начнется процесс преобразования структуры образа системы, учитывая специальный префикс и сохранение в монтируемый файл. Второй файл можно только читать, при этом он имеет одно из следующих значений: SAVED и UNSAVED, показывающие есть ли несохраненные изменения.

Это единственные файлы, которые никак не участвуют в сериализации. Удалить их нельзя.

### Атрибуты файлов

* uid и gid определяются во время монтирования (изменить нельзя).
* Объем файла равен длине строкового представления данных.
* Объем директории 0, исключение `..` корня файловой системы.
* Права (изменить нельзя):
	* для JSON директорий: 0775,
	* для JSON файлов: 0666,
	* для `.status`: 0444,
	* для `.save`: 0666.
* Время:
	* atime (время последнего чтения),
	* mtime (время последней записи),
	* ctime (время последнего изменения метаданных).
	При создании они инициализированны временем создания.
* Ссылки:
	* для директорий: 2 + количество поддиректорий,
	* для файлов: 1.	

## Использование

### Монтирование и размонтирование

#### Монтирование:

```bash
jsonfs <json_file> <mount_point> [fuse_options]
```

* json_file обязательный параметр, который должен быть валидным файлом формата JSON, соответствующий RFC 8259.
* mount_point обязательный параметр. Каталог, который должен быть пустым, и соответствовать полномочиям пользователя.
* fuse_options необязательный параметр для FUSE модуля, обычно используется -f или -d для отладки.

#### Размонтирование:

```bash
fusermount3 -u <mount_point>
```

* mount_point обязательный параметр. Каталог, в который был монтирован jsonfs.

### Функциональность

Следующие функции определены в src/fuse_callbacks.c. Они показывают функциональную полноту системы. Для более подробной информации об их назначении используйте `man 2 <функция>`.

* getattr (получение атрибутов файла),
* mknod (создание файла),
* mkdir (создание директории),
* unlink (удаление файла),
* rmdir (удаление директории),
* rename (переименование, перемещение),
* truncate (изменение размера файла),
* open (открытие файла),
* read (чтение),
* write (запись),
* readdir (чтение директории),
* destroy (очистка данных при размонтировании),
* utimens (управление временными метками).

В рамках этого руководства не будет описано как производить базовые операции над файлами. Изучайте этого в рамках освоения вашей командной оболочки.

### Примечания о чтении и записи

Файловая система поддерживает работу с текстовыми редакторами, например vim, nano. Так как бинарные файлы не поддерживаются (см. [Общие принципы](#общие-принципы)), система блокирует создание swap файлов от редакторов, что может привести к неопределенному поведению, но до сих пор ошибок связанных с этим замечены не были. 

Содержимое файлов без `\n` в конце, поэтому рекомендуется после вывода использовать `echo`, например:

```bash
cat phone ; echo
```

### Сохранение

Ознакомтесь с тем что такое [специальные файлы](#специальные-файлы). Триггер сохранения срабатывает именно с началом записи, поэтому не важно что именно вы туда будете записывать, его содержимое не изменится и всегда будет равно [значению по умлочанию](#общие-принципы). Сохранение производится в тот же файл, что вы монтировали, по этому рекомендуется делать копии. Если во время работы файловой системы вы удалите исходный JSON, то при сохранении он создаться с таким же названием.

Команда сохранения может выглядить вот так:

```bash
echo '1' | cat > .save
```

Статус можно посмотреть вот так:

```bash
cat .status ; echo
```

## Ошибки при использовании

### Ошибки во время сборки

Если вы столкнулись с ошибкой во время компиляции, значит нужно

* проверить выполнение [предусловий](#предусловия). В зависимости от дистрибутива, название для linfuse3-dev и libjansson-dev могут быть другие. Так же обратите внимание, что у пакетов суффикс `-dev`, это важно,
* проверить целостность проекта. Попробуйте скачать повторно (см. [Получение проекта](#получение-проекта)).

### Ошибка во время монтирования

Если после команды [монтирования](#монтирование) в stderr будет `jsonfs: failed to initialize filesystem`, то проблема связана скорее всего с файлом JSON, который вы передали в качетсве параметра. Откройте его через текстовый редактор, который имеет подсветку синтаксиса, и проверьте.

### Ошибки во время записи в файл

Чаще всего связано с попыткой записи невалидного литерала. Если для записи вы используете `cat` или похожую на нее программу, то в stderr будет `write error: Invalid argument`, а для текстовых редакторов будет ошибка, которая позволит выйти из программы только без сохранения.

Обратите внимание, написано ли без ошибок: null, true или false. Может быть слишком большое значение для целого типа или слишком точное для плавующей точки. Строки должны быть строго в `""`. Часто ошбика бывает именно с этим типом данных, если пользователь дописывает данные с помощью `cat >> file ` или пишет со смещением.

Из-а проблемы с обработкой бинарных файлов, и блокировки создания swap файлов, проблема может быть связанна именно с этим, так что попробуйте сменить текстовый редактор.

### Неправильное сохранение

То как происходит сериализация подробно описано в [Десериализация и сериализация](#десериализация-и-сериализация). В первую очередь найдите файлы в системе, у которых есть символ `@`, а потом посмотрите случаи где они используются.

Ниже продублированы неочевидные и важные моменты работы системы:

> **WARNING**: ЕСЛИ ХОТЯ БЫ ОДИН ФАЙЛ ИЛИ КАТАЛОГ ИМЕЕТ В КАЧЕСТВЕ ПЕРВЫХ СИМВОЛОВ СПЕЦИАЛЬНЫЙ ПРЕФИКС, ТО ЕГО РОДИТЕЛЬ БУДЕТ СЕРИАЛИЗОВАТЬСЯ КАК МАССИВ, В ТОМ ЧИСЛЕ КОРЕНЬ! ИСКЛЮЧЕНИЕ ПРИМИТИВ ВЕРХНЕГО УРОВНЯ И СПЕЦИАЛЬНОЕ ОБОЗНАЧЕНИЕ СЛЕША, ОБА УПОМЯНУТЫ ДАЛЕЕ.

> **WARNING**: ЕСЛИ В КОРНЕ ФАЙЛОВОЙ СИСТЕМЫ ВСТРЕТИТСЯ ФАЙЛ С ИМЕНЕМ `@scalar`, ТО ПРИ СОХРАНЕНИИ В JSON ФАЙЛЕ БУДЕТ ТОЛЬКО ПРИМИТИВ, ВСЕ ОСТАЛЬНЫЕ ФАЙЛЫ БУДУТ ПРОИГНОРИРОВАНЫ. ЕСЛИ `@scalar` БУДЕТ НЕ В КОРНЕ, ОН БУДЕТ ЭЛЕМЕНТОМ МАССИВА.

> **WARNING**: ЕСЛИ `@2F` БУДУТ ПЕРВЫМИ СИМВОЛАМИ В НАЗВАНИИ, ФАЙЛ НЕ БУДЕТ ВОСПРИНИМАТЬСЯ КАК ЭЛЕМЕНТ МАССИВА.

## Обратная связь

Чтобы связаться с разработчиком, можете использовать почту zveror1806@gmail.com.
