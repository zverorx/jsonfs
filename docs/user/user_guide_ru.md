# Руководство пользователя

## Содержание

* [Предусловия](#предусловия)
* [Получение проекта](#получение-проекта)
	* [Скачать архив](#скачать-архив)
	* [Клонировать репозиторий](#клонировать-репозиторий)
* [Сборка](#сборка)
	* [Компиляция и установка](#компиляция-и-установка)
	* [Удаление](#удаление)
	* [Очистка](#очистка)
	* [Подсказки](#подсказки)
* [Система представления JSON в FS](#система-представления-json-в-fs)
	* [Предупреждение о массиве](#предупреждение-о-массиве)
	* [Предупреждение о скаляре](#предупреждение-о-скаляре)
	* [Предупреждение о слеше](#предупреждение-о-слеше)
* [Использование](#использование)
	* [Монтирование и размонтирование](#монтирование-и-размонтирование)
	* [Операции над файлами](#операции-над-файлами)
	* [Специальные операции](#специальные-операции)
* [Ошибки при использовании](#ошибки-при-использовании)

## Предусловия

Проверьте наличие следующих программ:

### Необходимые:

* `gcc`
* `make`
* `libjansson-dev`
* `libfuse3-dev`

>P.S. Для установки libfuse3-dev и libjansson-dev используйте ваш пакетный менеджер.

### Опциональные:

* `curl` и `unzip` — если скачиваете архив,
* `git` — если планируете клонировать репозиторий.

## Получение проекта

У вас есть два варианта:

### Скачать архив:

```bash
curl -L -o jsonfs.zip https://github.com/zverorx/jsonfs/archive/refs/tags/latest.zip
```

```bash
unzip jsonfs.zip
```

### Клонировать репозиторий:

```bash
git clone https://github.com/zverorx/jsonfs.git
```

## Сборка

make выполняется исключительно в директории проекта.

Если у вас возникли ошибки после команды make, проверьте наличие [Предусловия](#предусловия).

### Компиляция и установка

Перейдите в директорию проекта и выполните:

```bash
make && sudo make install
```

Исполняемый файл окажется в директории bin/. В obj/ будут находится файлы промежуточного этапа компиляции (объектные файлы).

Установка подразумевает перемещение bin/jsonfs в /usr/local/bin/. По желанию этот путь можно изменить, переопределив переменную PREFIX.

Например:

```bash
sudo make install PREFIX=mydir
```

Тогда bin/jsonfs будет перемещен в mydir/.

### Удаление

Удаление работает по аналогии с установкой, из директории /usr/local/bin/ будет удален файл jsonfs.

```bash
sudo make uninstall
```

Место, откуда требуется удалить, тоже можно изменить переменной PREFIX:

```bash
sudo make uninstall PREFIX=mydir
```

Тогда jsonfs удалится из mydir/.

### Очистка

Makefile дает возможность удалить файлы, которые являются результатом компиляции.

> Содержимое obj/ и bin/ описано в [Компиляция и установка](#компиляция-и-установка).

Удаление obj/:

```bash
make clean
```

Удаление obj/ и bin/:

```bash
make distclean
```

### Подсказки

Чтобы вспомнить возможности Makefile проекта, необязятельно перечитывать руководство, достаточно воспользоваться:

```bash
make help
```

## Система представления JSON в FS

Валидный JSON соответствует стандарту RFC 8259, в том числе примитив верхнего уровня. Сохранение последовательности пар "ключ": значение не гарантируется. Десериализация монтируемого файла и сериализация при сохранении, реализуется с помощью библиотеки libjansson, так что может быть полезно ознакомится с их документацией по ссылке https://jansson.readthedocs.io/en/latest/index.html.

Некоторые значения не могу быть представлены в рамках любой файловой системы по естественным причинам. Общее правило формирования содержимого точки монтирования: ключ - название файла, значение - содержимое файла. Следовательно для элементов массива и для скаляров возникают проблемы, так как отсутствует ключ. Для однозначной идентификации подобных значений, испольуется специальный префикс: '@'. 

Например:

```json
{
  "user": "Ivan Petrov", 
  "interests": ["photography", "cooking", "skiing"],
  "phone": null,
  "profile": {
    "city": "Saint Petersburg",
    "street": "Nevsky Prospect",
    "apartment": 45
  }
}
```

Будет представлено как

```
.
├── interests
│   ├── @0
│   ├── @1
│   └── @2
├── phone
├── profile
│   ├── apartment
│   ├── city
│   └── street
└── user
```
Обратите внимание на массив interests, где появились файлы @0, @1, @2, которые содержат значения "photography", "cooking", "skiing" соответственно. Такой файл, расположенный в корне фалововй сиситемы, сделает из JSON массив. Все что идет после специального префикса не важно, главное чтобы удовлетворяло общепринятым правилам именования файлов.

#### Предупреждение о массиве

> WARNING: ЕСЛИ ХОТЯ БЫ ОДИН ФАЙЛ ИЛИ КАТАТЛОГ ИМЕЕТ В КАЧЕСТВЕ ПЕРВОГО СИМВОЛА СИМВОЛ '@', ТО ЕГО РОДИТЕЛЬ БУДЕТ СЕРИАЛИЗОВАТЬСЯ КАК МАССИВ! ИСКЛЮЧЕНИЕ @scalar В КОРНЕ И СПЕЦИАЛЬНОЕ ОБОЗНАЧЕНИЕ СЛЕША, ОБА УПОМЯНУТЫ ДАЛЕЕ.

В рамках jsonfs скаляром называется примитив любого типа, соответствующий RFC 8259. Он оборачивается в файл, с названием @scalar.

#### Предупреждение о скаляре

> WARNING: ЕСЛИ В КОРНЕ ФАЙЛОВОЙ СИСТЕМЫ ВСТРЕТИТСЯ ФАЙЛ С ИМЕНЕМ @scalar, ТО ПРИ СОХРАНЕНИИ В JSON ФАЙЛЕ БУДЕТ ТОЛЬКО ПРИМИТИВ, ВСЕ ОСТАЛЬНЫЕ ФАЙЛЫ БУДУТ ПРОИГНОРИРОВАННЫ. ЕСЛИ @scalar БУДЕТ НЕ В КОРНЕ, ОН БУДЕТ ЭЛЕМЕНТОМ МАССИВА.

* Пример десериализации:

```json
123
```

||

\\/

```
.
└── @scalar (содержит 123)
```

* Пример сериализации:

```
.
├── file1
├── file2
└── @scalar (содержит 123)
```

||

 \\/

```json
123
```

Кроме всего выше перечисленного, есть еще один случай использования специального префикса, если ключ имеет символ '/' в названии.

#### Предупреждение о слеше

> WARNING: ЕСЛИ В ИСХОДНОМ ФАЙЛЕ JSON ЕСТЬ КЛЮЧ С СИМВОЛОМ '/' ТО ОН БУДЕТ ИЗМЕНЕН В ФАЙЛОВОЙ СИСТЕМЕ НА '@2F'.  ЕСЛИ ВЫ В ФАЙЛОВОЙ СИСТЕМЕ СОЗДАДИТЕ ФАЙЛ С СИМВОЛАМИ '@2F' ТО ПРИ СОХРАНЕНИИ ОНИ БУДУТ ЗАМЕНЕНЫ НА '/'. ЕСЛИ '@2F' БУДУТ ПЕРВЫМИ СИМВОЛАМИ В НАЗВАНИИ, ФАЙЛ НЕ БУДЕТ ВОСПРИНИМАТЬСЯ КАК ЭЛЕМЕНТ МАССИВА.